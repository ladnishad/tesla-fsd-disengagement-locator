<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>FSD Disengagements</title>
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.js"></script>
    <link
      href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js"></script>
    <link
      rel="stylesheet"
      href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css"
      type="text/css"
    />
    <script src="https://npmcdn.com/@turf/turf/turf.min.js"></script>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mapbox-polyline/1.1.1/polyline.js></script>

    <script src=https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.2/mapbox-gl-directions.js></script>
    <link rel="stylesheet" href=https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.2/mapbox-gl-directions.css type="text/css" />

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      .info-box {
        position: absolute;
        margin-left: auto; 
        margin-right: 0;
        width: 25%;
        top: 0;
        bottom: 20px;
        padding: 20px;
        background-color: #fff;
        overflow-y: scroll;
      }

      .sidebar {
        position: absolute;
        margin: 20px 20px 30px 20px;
        width: 25%;
        top: 0;
        bottom: 0;
        padding: 20px;
        background-color: #fff;
        overflow-y: scroll;
      }

      .card {
        font-size: small;
        border-bottom: solid #d3d3d3 2px;
        margin-bottom: 6px;
      }

      .card-header {
        font-weight: bold;
        padding: 6px;
      }

      .no-route {
        background-color: #d3d3d3;
        color: #f00;
      }

      .obstacle-found {
        background-color: #d3d3d3;
        color: #fff;
      }

      .route-found {
        background-color: #33a532;
        color: #fff;
      }

      .card-details {
        padding: 3px 6px;
      }

    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="sidebar">
      <h1>Reports</h1>
      <div id="reports"></div>
    </div>

    <!-- Placeholder for directions for multiple nav points don't need for now -->
    <!-- <div class="info-box">
      <p>
        Draw your route using the draw tools on the right. To get the most
        accurate route match, draw points at regular intervals.
      </p>
      <div id="directions"></div>
    </div> -->
    <script>
      mapboxgl.accessToken =
        "pk.eyJ1IjoibGFkbmlzaGFkIiwiYSI6ImNsYWluZGh2czA0Z2szc3FqNnpzdHVjb24ifQ.zaJVETSXIzbg-Msz5gM_Rg";

      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/dark-v10",
        center: [-96.8029594, 32.7929756],
        zoom: 11,
      });

      const directions = new MapboxDirections({
          accessToken: mapboxgl.accessToken,
          unit: 'metric',
          profile: 'mapbox/driving',
          alternatives: false,
          geometries: 'geojson',
          controls: { instructions: false },
          flyTo: false
      });
      
      async function getDisengagements(){
        try {
          const response = await axios.get("https://isfsdbetaready.com/view-disengagements")
          return response.data
        } catch (e) {
          throw new Error(e);
        }
      }

      const counter = 0;
      const maxAttempts = 50;
      const emoji = '';
      const collision = '';
      const detail = '';
      const reports = document.getElementById('reports');
      const disengagements = getDisengagements()

      function addCard(id, element, clear, detail) {
        const card = document.createElement('div');
        card.className = 'card';
        // Add the response to the individual report created above
        const heading = document.createElement('div');
        // Set the class type based on clear value
        heading.className =
          clear === true ? 'card-header route-found' : 'card-header obstacle-found';
        heading.innerHTML =
          id === 0
            ? `${emoji} The route ${collision}`
            : `${emoji} Route ${id} ${collision}`;

        const details = document.createElement('div');
        details.className = 'card-details';
        details.innerHTML = `This ${detail} disengagements.`;

        card.appendChild(heading);
        card.appendChild(details);
        element.insertBefore(card, element.firstChild);
      }

      function noRoutes(element) {
        const card = document.createElement('div');
        card.className = 'card';
        // Add the response to the individual report created above
        const heading = document.createElement('div');
        heading.className = 'card-header no-route';
        emoji = 'üõë';
        heading.innerHTML = `${emoji} Ending search.`;

        // Add details to the individual report
        const details = document.createElement('div');
        details.className = 'card-details';
        details.innerHTML = `No clear route found in ${counter} tries.`;

        card.appendChild(heading);
        card.appendChild(details);
        element.insertBefore(card, element.firstChild);
      }

      map.addControl(directions, 'top-right');
      map.scrollZoom.enable();
      
      // we will add more code here in the next steps
      map.on("load", async () => {
        map.addSource("disengagements", {
          type: "geojson",
          data: "https://isfsdbetaready.com/view-disengagements",
        });

        // TODO: update api to return pure db values and then use helper function to convert to geoJSON
        const obstacle = turf.buffer(disengagements, 0.25, { units: 'kilometers' });
        const bbox = [0, 0, 0, 0];
        const polygon = turf.bboxPolygon(bbox);

        map.addSource('theRoute', {
          type: 'geojson',
          data: {
            type: 'Feature'
          }
        });
          
        map.addLayer({
          id: 'theRoute',
          type: 'line',
          source: 'theRoute',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-color': '#cccccc',
            'line-opacity': 0.5,
            'line-width': 13,
            'line-blur': 0.5
          }
        });

        // Source and layer for the bounding box
        map.addSource('theBox', {
          type: 'geojson',
          data: {
            type: 'Feature'
          }
        });
        map.addLayer({
          id: 'theBox',
          type: 'fill',
          source: 'theBox',
          layout: {},
          paint: {
            'fill-color': '#FFC300',
            'fill-opacity': 0.5,
            'fill-outline-color': '#FFC300'
          }
        });

        directions.on('clear', () => {
          map.setLayoutProperty('theRoute', 'visibility', 'none');
          map.setLayoutProperty('theBox', 'visibility', 'none');

          counter = 0;
          reports.innerHTML = '';
        });

        directions.on('route', (e) => {
          // Hide the route and box by setting the opacity to zero
          map.setLayoutProperty('theRoute', 'visibility', 'none');
          map.setLayoutProperty('theBox', 'visibility', 'none');

          if (counter >= maxAttempts) {
            noRoutes(reports);
          }

          else {
            const { route, duration } = e
          
            route.forEach((eachRoute) => {
              // Make each route visible
              map.setLayoutProperty('theRoute', 'visibility', 'visible');
              map.setLayoutProperty('theBox', 'visibility', 'visible');


              // Get GeoJSON LineString feature of route
              const routeLine = polyline.toGeoJSON(route.geometry);

              // Create a bounding box around this route
              // The app will find a random point in the new bbox
              bbox = turf.bbox(routeLine);
              polygon = turf.bboxPolygon(bbox);
              
              // Update the data for the route
              // This will update the route line on the map
              map.getSource('theRoute').setData(routeLine);
              
              // Update the box
              map.getSource('theBox').setData(polygon);

              const clear = turf.booleanDisjoint(obstacle, routeLine);

              if (clear === true) {
                collision = 'does not have any reported disengagements!';
                detail = `takes ${(duration / 60).toFixed(0)} minutes and avoids`;
                emoji = '‚úîÔ∏è';
                map.setPaintProperty('theRoute', 'line-color', '#74c476');
                // Hide the box
                map.setLayoutProperty('theBox', 'visibility', 'none');
                // Reset the counter
                counter = 0;
              } else {
                // disengagement intersection occurred, so increment the counter
                counter = counter + 1;
                // As the attempts increase, expand the search area
                // by a factor of the attempt count
                polygon = turf.transformScale(polygon, counter * 0.01);
                bbox = turf.bbox(polygon);
                collision = 'is bad.';
                detail = `takes ${(duration / 60).toFixed(0)} minutes and hits`;
                emoji = '‚ö†Ô∏è';
                map.setPaintProperty('theRoute', 'line-color', '#de2d26');

                // Add a randomly selected waypoint to get a new route from the Directions API
                const randomWaypoint = turf.randomPoint(1, { bbox: bbox });
                directions.setWaypoint(
                0,
                randomWaypoint['features'][0].geometry.coordinates
                );
              }

              // Add a new report section to the sidebar
              addCard(counter, reports, clear, detail);
            })
          }
        });
        // add heatmap layer here
        map.addLayer(
          {
            id: "disengagement-heat",
            type: "heatmap",
            source: "disengagements",
            maxzoom: 15,
            paint: {
              // increase weight as diameter breast height increases
              // "heatmap-weight": {
              //   property: "dbh",
              //   type: "exponential",
              //   stops: [
              //     [1, 0],
              //     [62, 1]
              //   ]
              // },
              // increase intensity as zoom level increases
              "heatmap-intensity": {
                stops: [
                  [11, 1],
                  [15, 3],
                ],
              },
              // assign color values be applied to points depending on their density
              "heatmap-color": [
                "interpolate",
                ["linear"],
                ["heatmap-density"],
                0,
                "rgba(33,102,172,0)",
                0.2,
                "rgb(103,169,207)",
                0.4,
                "rgb(209,229,240)",
                0.6,
                "rgb(253,219,199)",
                0.8,
                "rgb(239,138,98)",
                1,
                "rgb(178,24,43)",
              ],
              // increase radius as zoom increases
              "heatmap-radius": {
                stops: [
                  [11, 15],
                  [15, 20],
                ],
              },
              // decrease opacity to transition into the circle layer
              "heatmap-opacity": {
                default: 1,
                stops: [
                  [14, 1],
                  [15, 0],
                ],
              },
            },
          },
          "waterway-label"
        );

        // add circle layer here
        map.addLayer(
          {
            id: "disengagement-point",
            type: "circle",
            source: "disengagements",
            minzoom: 14,
            paint: {
              // increase the radius of the circle as the zoom level and dbh value increases
              // "circle-radius": {
              //   property: "dbh",
              //   type: "exponential",
              //   stops: [
              //     [{ zoom: 15, value: 1 }, 5],
              //     [{ zoom: 15, value: 62 }, 10],
              //     [{ zoom: 22, value: 1 }, 20],
              //     [{ zoom: 22, value: 62 }, 50]
              //   ]
              // },
              // "circle-color": {
              //   property: "dbh",
              //   type: "exponential",
              //   stops: [
              //     [0, "rgba(236,222,239,0)"],
              //     [10, "rgb(236,222,239)"],
              //     [20, "rgb(208,209,230)"],
              //     [30, "rgb(166,189,219)"],
              //     [40, "rgb(103,169,207)"],
              //     [50, "rgb(28,144,153)"],
              //     [60, "rgb(1,108,89)"]
              //   ]
              // },
              // "circle-stroke-color": "white",
              "circle-stroke-width": 1,
              "circle-opacity": [
                "interpolate",
                ["linear"],
                ["zoom"],
                7,
                0,
                8,
                1,
              ],
            },
          },
          "waterway-label"
        );

        map.addControl(
          new mapboxgl.GeolocateControl({
            positionOptions: {
              enableHighAccuracy: true,
            },
            // When active the map will receive updates to the device's location as it changes.
            // trackUserLocation: true,
            // Draw an arrow next to the location dot to indicate which direction the device is heading.
            showUserHeading: true,
          })
        );

        map.on("click", "disengagement-point", (event) => {
          new mapboxgl.Popup()
            .setLngLat(event.features[0].geometry.coordinates)
            .setHTML(
              `<strong>Car Model:</strong> ${event.features[0].properties.carModel}`
            )
            .addTo(map);
        });
      });
    </script>
  </body>
</html>
